/**
 * Generates Swift code that bundles pre-rendered widget initial states.
 */
export function generateInitialStatesSwift(prerenderedStates: Map<string, string>): string {
  if (prerenderedStates.size === 0) {
    return generateEmptyInitialStatesSwift()
  }

  // Generate the bundled states dictionary
  const stateEntries = Array.from(prerenderedStates.entries())
    .map(([widgetId, json]) => {
      const delimiter = getSwiftRawStringDelimiter(json)
      return `      "${widgetId}": ${delimiter}"${json}"${delimiter}`
    })
    .join(',\n')

  return `//
//  VoltraWidgetInitialStates.swift
//
//  Auto-generated by Voltra config plugin.
//  Contains pre-rendered initial states for home screen widgets.
//

import Foundation

public enum VoltraWidgetInitialStates {
    private static let bundledStates: [String: String] = [
${stateEntries}
    ]

    /// Get the bundled initial state JSON for a widget.
    /// Returns nil if no initial state was configured for the widget.
    public static func getInitialState(for widgetId: String) -> Data? {
        guard let jsonString = bundledStates[widgetId] else { return nil }
        return jsonString.data(using: .utf8)
    }
}
`
}

/**
 * Generates empty Swift code when no widgets have initial states configured.
 */
function generateEmptyInitialStatesSwift(): string {
  return `//
//  VoltraWidgetInitialStates.swift
//
//  Auto-generated by Voltra config plugin.
//  No widget initial states configured.
//

import Foundation

public enum VoltraWidgetInitialStates {
    /// Get the bundled initial state JSON for a widget.
    /// Always returns nil since no initial states are configured.
    public static func getInitialState(for widgetId: String) -> Data? {
        return nil
    }
}
`
}

/**
 * Determines the appropriate Swift raw string delimiter for a given string.
 * Counts the maximum consecutive '#' characters after a '"' in the content
 * and returns a delimiter with one more '#' than that maximum.
 *
 * For example:
 * - Content has no '"#' → returns '#'
 * - Content has '"#' (1 hash) → returns '##'
 * - Content has '"##' (2 hashes) → returns '###'
 */
function getSwiftRawStringDelimiter(str: string): string {
  // Find all sequences of '#' that follow a '"'
  const matches = str.match(/"#+/g)

  if (!matches) {
    return '#'
  }

  // Find the maximum number of consecutive '#' after a '"'
  const maxHashes = Math.max(...matches.map((m) => m.length - 1)) // -1 to exclude the '"'
  return '#'.repeat(maxHashes + 1)
}
